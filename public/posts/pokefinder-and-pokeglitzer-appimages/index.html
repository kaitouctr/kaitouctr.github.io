<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Creating AppImages for PokeFinder and PokeGlitzer | kazumarks</title>
<meta name=keywords content="pokemon,linux"><meta name=description content="This stuff is simply documenting my experience in trying to create AppImages for the aforementioned applications
Background I have been running a set up based around Fedora Atomic Desktops for a while now. These operating systems use OS images as the main method of delivering updates and expect a container-based workflow. I also like to play around with Pokémon, particularly the technical side of it such as pseudorandom number generation (PRNG) manipulation and glitching around (particularly in Generation III)."><meta name=author content><link rel=canonical href=http://localhost:1313/posts/pokefinder-and-pokeglitzer-appimages/><link crossorigin=anonymous href=/assets/css/stylesheet.d452010bd9736c57f2e29796155471ecd19739dd3f3871e4e6b5d58c4a6178cf.css integrity="sha256-1FIBC9lzbFfy4peWFVRx7NGXOd0/OHHk5rXVjEpheM8=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/pokefinder-and-pokeglitzer-appimages/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Creating AppImages for PokeFinder and PokeGlitzer"><meta property="og:description" content="This stuff is simply documenting my experience in trying to create AppImages for the aforementioned applications
Background I have been running a set up based around Fedora Atomic Desktops for a while now. These operating systems use OS images as the main method of delivering updates and expect a container-based workflow. I also like to play around with Pokémon, particularly the technical side of it such as pseudorandom number generation (PRNG) manipulation and glitching around (particularly in Generation III)."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/pokefinder-and-pokeglitzer-appimages/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-04T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-04T00:00:00+00:00"><meta property="og:site_name" content="kazumarks"><meta name=twitter:card content="summary"><meta name=twitter:title content="Creating AppImages for PokeFinder and PokeGlitzer"><meta name=twitter:description content="This stuff is simply documenting my experience in trying to create AppImages for the aforementioned applications
Background I have been running a set up based around Fedora Atomic Desktops for a while now. These operating systems use OS images as the main method of delivering updates and expect a container-based workflow. I also like to play around with Pokémon, particularly the technical side of it such as pseudorandom number generation (PRNG) manipulation and glitching around (particularly in Generation III)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Creating AppImages for PokeFinder and PokeGlitzer","item":"http://localhost:1313/posts/pokefinder-and-pokeglitzer-appimages/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Creating AppImages for PokeFinder and PokeGlitzer","name":"Creating AppImages for PokeFinder and PokeGlitzer","description":"This stuff is simply documenting my experience in trying to create AppImages for the aforementioned applications\nBackground I have been running a set up based around Fedora Atomic Desktops for a while now. These operating systems use OS images as the main method of delivering updates and expect a container-based workflow. I also like to play around with Pokémon, particularly the technical side of it such as pseudorandom number generation (PRNG) manipulation and glitching around (particularly in Generation III).","keywords":["pokemon","linux"],"articleBody":"This stuff is simply documenting my experience in trying to create AppImages for the aforementioned applications\nBackground I have been running a set up based around Fedora Atomic Desktops for a while now. These operating systems use OS images as the main method of delivering updates and expect a container-based workflow. I also like to play around with Pokémon, particularly the technical side of it such as pseudorandom number generation (PRNG) manipulation and glitching around (particularly in Generation III). However the tools used for these activities were definitely not distributed with this kind of system.\nPokeFinder (a tool that simulates the PRNG of various Pokémon games) is just distributed as a binary executable file. This format does not include any dependencies that the software may rely on, which on atomic distributions necessitates a container (in PokeFinder’s case is really only the case for GNOME-based distributions as KDE-based ones have Qt already). I don’t particularly like having to create a brand new container just to be able to run an application as I feel it creates quite a bit of bloat.\nPokeGlitzer is not much better. It is shipped as an artifact from a dotnet build command without any kind of self-containment. As dotnet is usually not installed on most Linux distributions, this means that has to be downloaded first before being able to use the program. On atomic distributions it inherits the same issues as binary executables, and thus also needs a container.\nHowever, for myself anyway, there is a format that allows me to contain the binary and all of its dependencies into one file. It is the AppImage format, largely because of how simple it is to get an application up and running with all of its dependencies bundled in.\nBuilding PokeFinder This one caused me the least amount of headaches so I will start with this. First I the PokeFinder binary from the GitHub I simply followed most of this. I placed PokeFinder in AppDir/usr/bin, created a .desktop file at AppDir/usr/share/applications, got PokeFinder.ico from Source/Form/Images folder in the GitHub repository (converted with ImageMagick, chose the largest size) then ran the appimagetool found at the probonopd/go-appimage repository. Below is an approximation of the commands I have used:\n./appimagetool*.AppImage -s deploy AppDir/usr/share/applications/PokeFinder.desktop\r./appimagetool*.AppImage AppDir Building PokeGlitzer To make the process of building the appimage simpler, I did have to install dotnet and clone the PokeGlitzer repository from GitHub. The dotnet was in a container, also make sure the container’s base distribution is Ubuntu 20.04 LTS (this will save quite a bit of annoyance in later parts). I cd’d into the cloned repository and ran the below command:\ndotnet publish -r linux-x64 -o ../AppDir/usr/bin --sc true This produces a folder that contains a lot of files, but the most important thing about it is that it bundles dotnet within it eliminating the need to download it separately. In theory the job is already done by that folder full of files but it does not feel elegant having to zip and unzip that all the time and needing to search through for the binary produced by dotnet.\nThen using this guide, I created the AppRun with the following content (with chmod 755 applied onto it):\n#!/bin/sh\rHERE=\"$(dirname \"$(readlink -f \"${0}\")\")\"\rexport PATH=\"${HERE}\"/usr/bin/:\"${PATH}\"\rEXEC=$(grep -e '^Exec=.*' \"${HERE}\"/*.desktop | head -n 1 | cut -d \"=\" -f 2 | cut -d \" \" -f 1)\rexec \"${EXEC}\" $@ And the PokeGlitzer.desktop :\n# Desktop Entry Specification: https://standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html\r[Desktop Entry]\rType=Application\rName=PokeGlitzer\rComment=Gen3 Save Editor for Glitchers\rIcon=pokeglitzer\rExec=PokeGlitzer\rPath=~\rTerminal=false\rCategories=Utility; Also I have copied the icon from the PokeGlitzer/Resources folder within the PokeGlitzer GitHub repository to serve as the icon for the AppImage. There the folder structure all prepared! Then I had to install the below packages in the container to make sure that the AppImage building works properly.\nsudo apt install file squashfs-tools libsquash-dev liblttng-ust0 Note that liblttng-ust0 is an old version of the lttng library which means that newer distributions most likely do not have it available, thus the requirement that the container must run Ubuntu 20.04. Also I did not know for quite a long time that I needed to install file, as the error message that appimagetool printed out was confusing:\nRequired helper tool file is not found I honestly thought that there was a helper tool file somewhere that AppImage needed but then I slowly realised that it was the helper tool file not a helper tool file that I needed. I think wasted so much time on that.\nAfter all that, I ran the same command as I did with PokeFinder to package it all into an AppImage and then I was done.\n./appimagetool*.AppImage AppDir Conclusion Yes, I literally just regurgitated the official AppImage guides on how to make AppImages. This was just detailing my experience in trying to create an AppImage for these two apps just so I can run them for my specific Linux environment.\n","wordCount":"821","inLanguage":"en","datePublished":"2024-08-04T00:00:00Z","dateModified":"2024-08-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/pokefinder-and-pokeglitzer-appimages/"},"publisher":{"@type":"Organization","name":"kazumarks","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="kazumarks (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>kazumarks</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a></div><h1 class="post-title entry-hint-parent">Creating AppImages for PokeFinder and PokeGlitzer
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2024-08-04 00:00:00 +0000 UTC'>2024-08-04</span></div></header><div class=post-content><p><strong>This stuff is simply documenting my experience in trying to create AppImages for the aforementioned applications</strong></p><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><p>I have been running a set up based around Fedora Atomic Desktops for a while now. These operating systems use OS images as the main method of delivering updates and expect a container-based workflow. I also like to play around with Pokémon, particularly the technical side of it such as pseudorandom number generation (PRNG) manipulation and glitching around (particularly in Generation III). However the tools used for these activities were definitely not distributed with this kind of system.</p><p>PokeFinder (a tool that simulates the PRNG of various Pokémon games) is just distributed as a binary executable file. This format does not include any dependencies that the software may rely on, which on atomic distributions necessitates a container (in PokeFinder’s case is really only the case for GNOME-based distributions as KDE-based ones have Qt already). I don’t particularly like having to create a brand new container just to be able to run an application as I feel it creates quite a bit of bloat.</p><p>PokeGlitzer is not much better. It is shipped as an artifact from a <code>dotnet build</code> command without any kind of self-containment. As <code>dotnet</code> is usually not installed on most Linux distributions, this means that has to be downloaded first before being able to use the program. On atomic distributions it inherits the same issues as binary executables, and thus also needs a container.</p><p>However, for myself anyway, there is a format that allows me to contain the binary and all of its dependencies into one file. It is the AppImage format, largely because of how simple it is to get an application up and running with all of its dependencies bundled in.</p><h2 id=building-pokefinder>Building PokeFinder<a hidden class=anchor aria-hidden=true href=#building-pokefinder>#</a></h2><p>This one caused me the least amount of headaches so I will start with this. First I the PokeFinder binary from the <a href=https://github.com/Admiral-Fish/PokeFinder>GitHub</a> I simply followed most of <a href=https://docs.appimage.org/packaging-guide/from-source/native-binaries.html>this</a>. I placed <code>PokeFinder</code> in <code>AppDir/usr/bin</code>, created a <code>.desktop</code> file at <code>AppDir/usr/share/applications</code>, got <code>PokeFinder.ico</code> from <code>Source/Form/Images</code> folder in the GitHub repository (converted with ImageMagick, chose the largest size) then ran the <code>appimagetool</code> found at the <a href=https://github.com/probonopd/go-appimage>probonopd/go-appimage</a> repository. Below is an approximation of the commands I have used:</p><pre tabindex=0><code>./appimagetool*.AppImage -s deploy AppDir/usr/share/applications/PokeFinder.desktop
./appimagetool*.AppImage AppDir
</code></pre><h2 id=building-pokeglitzer>Building PokeGlitzer<a hidden class=anchor aria-hidden=true href=#building-pokeglitzer>#</a></h2><p>To make the process of building the appimage simpler, I did have to install <code>dotnet</code> and clone the <a href=https://github.com/E-Sh4rk/PokeGlitzer>PokeGlitzer repository</a> from GitHub. The <code>dotnet</code> was in a container, also make sure the container’s base distribution is Ubuntu 20.04 LTS (this will save quite a bit of annoyance in later parts). I cd’d into the cloned repository and ran the below command:</p><pre tabindex=0><code>dotnet publish -r linux-x64 -o ../AppDir/usr/bin --sc true
</code></pre><p>This produces a folder that contains a lot of files, but the most important thing about it is that it bundles <code>dotnet</code> within it eliminating the need to download it separately. In theory the job is already done by that folder full of files but it does not feel elegant having to zip and unzip that all the time and needing to search through for the binary produced by <code>dotnet</code>.</p><p>Then using <a href=https://github.com/AppImage/AppImageKit/wiki/Bundling-.NET-Core-apps#bundling-within-a-docker-container>this guide</a>, I created the <code>AppRun</code> with the following content (with <code>chmod 755</code> applied onto it):</p><pre tabindex=0><code>#!/bin/sh
HERE=&#34;$(dirname &#34;$(readlink -f &#34;${0}&#34;)&#34;)&#34;
export PATH=&#34;${HERE}&#34;/usr/bin/:&#34;${PATH}&#34;
EXEC=$(grep -e &#39;^Exec=.*&#39; &#34;${HERE}&#34;/*.desktop | head -n 1 | cut -d &#34;=&#34; -f 2 | cut -d &#34; &#34; -f 1)
exec &#34;${EXEC}&#34; $@
</code></pre><p>And the <code>PokeGlitzer.desktop</code> :</p><pre tabindex=0><code># Desktop Entry Specification: https://standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html
[Desktop Entry]
Type=Application
Name=PokeGlitzer
Comment=Gen3 Save Editor for Glitchers
Icon=pokeglitzer
Exec=PokeGlitzer
Path=~
Terminal=false
Categories=Utility;
</code></pre><p>Also I have copied the icon from the <code>PokeGlitzer/Resources</code> folder within the PokeGlitzer GitHub repository to serve as the icon for the AppImage. There the folder structure all prepared! Then I had to install the below packages in the container to make sure that the AppImage building works properly.</p><pre tabindex=0><code>sudo apt install file squashfs-tools libsquash-dev liblttng-ust0
</code></pre><p>Note that <code>liblttng-ust0</code> is an old version of the lttng library which means that newer distributions most likely do not have it available, thus the requirement that the container must run Ubuntu 20.04. Also I did not know for quite a long time that I needed to install <code>file</code>, as the error message that <code>appimagetool</code> printed out was confusing:</p><pre tabindex=0><code>Required helper tool file is not found
</code></pre><p>I honestly thought that there was a helper tool file somewhere that AppImage needed but then I slowly realised that it was the helper tool <code>file</code> not a helper tool file that I needed. I think wasted so much time on that.</p><p>After all that, I ran the same command as I did with PokeFinder to package it all into an AppImage and then I was done.</p><pre tabindex=0><code>./appimagetool*.AppImage AppDir
</code></pre><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Yes, I literally just regurgitated the official AppImage guides on how to make AppImages. This was just detailing my experience in trying to create an AppImage for these two apps just so I can run them for my specific Linux environment.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/pokemon/>Pokemon</a></li><li><a href=http://localhost:1313/tags/linux/>Linux</a></li></ul></footer></article></main><footer class=footer><span>© kazumarks 2024</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>